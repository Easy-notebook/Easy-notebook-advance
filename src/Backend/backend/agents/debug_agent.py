import asyncio
import re
from collections import deque
from typing import AsyncGenerator, Dict, Any, List

from .base_agent import BaseAgentTemplate


class DebugConverter:
    """Ë∞ÉËØïËΩ¨Êç¢Âô®ÔºåÂ§ÑÁêÜÊâßË°åÁªìÊûúÂíå‰ª£Á†Å"""
    
    def __init__(self):
        self.messages = []
        
    def _extract_image_metadata(self, image_data: str) -> Dict[str, str]:
        """Extract metadata from base64 image string."""
        pattern = r'data:image/(\w+);base64,'
        match = re.match(pattern, image_data)
        if not match:
            return {"format": "unknown"}
        return {"format": match.group(1)}

    def _process_execute_result(self, results: List[Dict]) -> List[Dict]:
        """Process execution results into chat messages."""
        messages = []
        
        for result in results:
            if result["type"] == "text":
                messages.append({
                    "role": "assistant",
                    "content": result["content"]
                })
            elif result["type"] == "image":
                messages.append({
                    "role": "user",
                    "content": [
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": result["content"]
                            }
                        },
                        {
                            "type": "text",
                            "text": f"Image generated at {result['timestamp']}"
                        }
                    ]
                })
        
        return messages

    def _process_code(self, code: str) -> Dict:
        """Process executed code into a message."""
        return {
            "role": "user",
            "content": f"Executed Python Code:[ÈúÄË¶ÅdebugÁöÑ‰ª£Á†ÅÁâáÊÆµ]\n```python\n{code}\n```"
        }

    def process_operation(self, operation: dict) -> List[Dict]:
        """Process operation into chat messages."""
        self.messages = []
        
        if "executeResult" in operation:
            self.messages.extend(
                self._process_execute_result(operation["executeResult"])
            )
        
        if "executeCode" in operation:
            self.messages.append(
                self._process_code(operation["executeCode"])
            )
        
        if "description" in operation:
            self.messages.append({
                "role": "user",
                "content": "‰ª£Á†ÅÂéüÊú¨ÁöÑÁõÆÊ†áÊòØÂìçÂ∫î:["+operation["description"]+"]"
            })
        
        if "historyCode" in operation:
            self.messages.append({
                "role": "user",
                "content": "ÂéÜÂè≤‰ª£Á†Å:["+operation["historyCode"]+"]"
            })
            
        return self.messages


class DebugAgent(BaseAgentTemplate):
    """
    Ë∞ÉËØïAgentÁ±ªÔºå‰∏ìÈó®Â§ÑÁêÜ‰ª£Á†ÅË∞ÉËØïÂíåÈîôËØØ‰øÆÂ§ç
    """

    def __init__(self, 
                 operation: Dict[str, Any] = None,
                 api_key: str = None,
                 base_url: str = None,
                 engine: str = "o4-mini",
                 role: str = None) -> None:
        """
        ÂàùÂßãÂåñË∞ÉËØï‰ª£ÁêÜ
        """
        if role is None:
            role = """You're an AI debugging assistant for EasyRemote notebooks. Analyze code and fix issues step by step.

When analyzing code:
1. Understand the code's purpose
2. Identify all errors (syntax, logic, runtime)
3. Fix issues with minimal changes
4. Preserve original functionality

In your response:
1. Briefly explain what caused each error
2. For each fix, explain your reasoning
3. End with ONLY ONE code block containing the complete fixed code
4. Add comments to mark your fixes: # FIXED: explanation

Example:

the original code your received is:
```python
print "hello"
```
the error is:
[error-message-for-debug]
  Cell In[22], line 1
    print "hello"
    ^
SyntaxError: Missing parentheses in call to 'print'. Did you mean print(...)?

your response should be:

the main purpose of the code is print "hello", but there is a syntax error, we should fix it.

In order to fix the syntax error, we should add parentheses required in original code.

Ok, my response is:

```python
print("hello")  # FIXED: Added parentheses for Python 3 syntax
```"""
        
        super().__init__(operation, api_key, base_url, engine, role)
        self.converter = DebugConverter()
        
    def validate_operation(self) -> bool:
        """È™åËØÅÊìç‰ΩúÂèÇÊï∞"""
        return bool(self.payload)
        
    def _build_system_messages(self) -> List[Dict[str, str]]:
        """ÊûÑÂª∫Á≥ªÁªüÊ∂àÊÅØ"""
        return [{"role": "system", "content": self.role}]

    async def process(self) -> AsyncGenerator[str, None]:
        """Â§ÑÁêÜË∞ÉËØïAgentÈÄªËæë"""
        if not self.validate_operation():
            yield self._create_response_json("error", {
                "error": "Invalid operation parameters"
            })
            return
            
        async for response in self.handle_code_debug():
            yield response

    async def handle_code_debug(self) -> AsyncGenerator[str, None]:
        """Â§ÑÁêÜ‰ª£Á†ÅË∞ÉËØïÔºåËÄÉËôëËÆ∞ÂøÜ"""
        try:
            print("Operation received code_debug")
            print("Operation", self.operation)
            
            # Ê£ÄÊü•ÁªàÊ≠¢Êù°‰ª∂
            should_terminate, terminate_reason = self._should_terminate()
            if should_terminate:
                yield self._create_response_json("convertCurrentCodeCellToHybridCell", {})
                yield self._create_response_json("updateCurrentCellWithContent", {
                    "payload": {
                        "content": f"üõë Ë∞ÉËØïÁªàÊ≠¢: {terminate_reason}\n\nÂª∫ËÆÆ:\n1. ÂõûÈ°æÈóÆÈ¢òÊú¨Ë¥®ÔºåÈáçÊñ∞ÂàÜÊûêÈúÄÊ±Ç\n2. ÂØªÊ±Ç‰∫∫Â∑•Â∏ÆÂä©ÊàñÊü•ÈòÖÊñáÊ°£\n3. Â∞ùËØïÂÆåÂÖ®‰∏çÂêåÁöÑÂÆûÁé∞ÊñπÊ°à\n4. ËÄÉËôëÁÆÄÂåñÈóÆÈ¢òÔºåÂàÜÊ≠•È™§Ëß£ÂÜ≥"
                    }
                })
                return
                
            # Ê£ÄÊü•ÊòØÂê¶ÊúâÁé∞ÊàêÁöÑËß£ÂÜ≥ÊñπÊ°à
            working_solutions = self._get_working_solutions()
            current_error = self.current_context.get("error_message", "")
            
            initial_content = "Agent is thinking and tend to debug...\n\n"
            
            # Ê£ÄÊü•ÂéÜÂè≤Ëß£ÂÜ≥ÊñπÊ°à
            found_solution = False
            for error_pattern, solution in working_solutions.items():
                if error_pattern.lower() in current_error.lower():
                    initial_content += f"üí° ÂèëÁé∞Á±ª‰ººÈóÆÈ¢òÁöÑÂéÜÂè≤Ëß£ÂÜ≥ÊñπÊ°à:\n**ÈîôËØØÊ®°Âºè**: {error_pattern}\n**Ëß£ÂÜ≥ÊñπÊ°à**: {solution}\n\n"
                    found_solution = True
                    break
                    
            # Ê£ÄÊü•Â∫îÈÅøÂÖçÁöÑÊñπÊ≥ï
            failed_approaches = self._get_avoided_approaches()
            if failed_approaches:
                initial_content += f"‚ö†Ô∏è ÈÅøÂÖç‰ª•‰∏ãÂ∑≤ËØÅÊòéÊó†ÊïàÁöÑÊñπÊ≥ï:\n"
                for approach in failed_approaches[:3]:  # Âè™ÊòæÁ§∫Ââç3‰∏™
                    initial_content += f"- {approach}\n"
                initial_content += "\n"
                
            # Ê£ÄÊü•‰ª£Á†ÅÁâàÊú¨‰ø°ÊÅØ
            if self.agent_memory:
                situation = self.agent_memory.get("situation_tracking", {})
                code_evolution = situation.get("code_evolution", {})
                working_versions = code_evolution.get("working_versions", [])
                if working_versions:
                    initial_content += f"üìã Ê£ÄÊµãÂà∞{len(working_versions)}‰∏™ÂéÜÂè≤Â∑•‰ΩúÁâàÊú¨ÔºåÂ¶ÇÈúÄË¶ÅÂèØÂª∫ËÆÆÂõûÊªö\n\n"
            
            # ‰ΩøÁî®DebugConverterÂ§ÑÁêÜÊìç‰Ωú
            chat_messages = self.converter.process_operation(self.payload)
            
            # ÊûÑÂª∫ËÆ∞ÂøÜÊÑüÁü•ÁöÑÊ∂àÊÅØ
            messages = self._build_system_messages()
            messages.extend(chat_messages)
            
            # Â¶ÇÊûúÊâæÂà∞Ëß£ÂÜ≥ÊñπÊ°àÔºåÊ∑ªÂä†ÁâπÊÆäÊåá‰ª§
            if found_solution:
                messages.append({
                    "role": "user",
                    "content": "ËØ∑‰ºòÂÖàÂ∞ùËØï‰∏äËø∞ÂéÜÂè≤Ëß£ÂÜ≥ÊñπÊ°àÔºåÂ¶ÇÊûú‰∏çÈÄÇÁî®ÂÜçÂàÜÊûêÊñ∞ÁöÑËß£ÂÜ≥ÊñπÊ°à„ÄÇ"
                })
            
            # ÂèëÈÄÅÂàùÂßãÂìçÂ∫î
            yield self._create_response_json("convertCurrentCodeCellToHybridCell", {})
            
            yield self._create_response_json("updateCurrentCellWithContent", {
                "payload": {
                    "content": initial_content
                }
            })
            
            # ‰ΩøÁî®Â∏¶ÁºìÂÜ≤ÁöÑÊµÅÂºèÂ§ÑÁêÜ
            buffer = deque(maxlen=50)
            async for response in self._handle_openai_stream(messages, buffer):
                yield response
                
        except Exception as e:
            print(f"Error in handle_code_debug: {str(e)}")
            yield self._create_response_json("error", {
                "error": str(e)
            })

    async def _handle_openai_stream(
        self, 
        messages: List[Dict[str, str]], 
        buffer: deque
    ) -> AsyncGenerator[str, None]:
        """Â§ÑÁêÜOpenAI APIÊµÅÂºèÂìçÂ∫î"""
        try:
            # Note: OpenAI SDK create() is synchronous, returns a Stream object
            stream = self.client.chat.completions.create(
                model=self.engine,
                messages=messages,
                stream=True,
                timeout=30.0
            )

            index = 0
            generated_analysis = ""
            last_flush_time = asyncio.get_event_loop().time()

            # Use regular for loop, not async for
            for chunk in stream:
                if not chunk.choices:
                    continue
                    
                content = chunk.choices[0].delta.content
                if not content:
                    continue
                    
                generated_analysis += content
                index += len(content)
                
                buffer.append(content)
                
                current_time = asyncio.get_event_loop().time()
                if current_time - last_flush_time >= 0.1 or len(buffer) >= 40:
                    combined_content = ''.join(buffer)
                    buffer.clear()
                    last_flush_time = current_time
                    
                    yield self._create_response_json("addNewContent2CurrentCell", {
                        "payload": {
                            "content": combined_content,
                        },
                        "status": "processing",
                        "index": index
                    })
                    
                    await asyncio.sleep(0.01)

                # Allow other coroutines to run
                await asyncio.sleep(0.001)
            
            # ÂèëÈÄÅÂâ©‰ΩôÁöÑÁºìÂÜ≤Âå∫ÂÜÖÂÆπ
            if buffer:
                combined_content = ''.join(buffer)
                yield self._create_response_json("addNewContent2CurrentCell", {
                    "payload": {
                        "content": combined_content,
                    },
                    "status": "processing",
                    "index": index
                })
            
            # ËøêË°å‰ª£Á†ÅÂçïÂÖÉÊ†º
            yield self._create_response_json("runCurrentCodeCell", {
                "payload": {},
                "status": "processing"
            })
                
        except asyncio.TimeoutError:
            print("Stream timeout")
            yield self._create_response_json("error", {
                "payload": {},
                "error": "Stream timeout"
            })
        except Exception as e:
            print(f"Error in _handle_openai_stream: {str(e)}")
            yield self._create_response_json("error", {
                "payload": {},
                "error": str(e)
            })