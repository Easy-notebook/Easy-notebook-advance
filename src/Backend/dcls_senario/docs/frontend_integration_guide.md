# ÂâçÁ´ØÈõÜÊàêÊåáÂçó - Êñ∞Â∑•‰ΩúÊµÅÊéßÂà∂Á≥ªÁªü
Frontend Integration Guide - New Workflow Control System

## Ê¶ÇËø∞ Overview

Êú¨ÊåáÂçóËØ¥ÊòéÂ¶Ç‰ΩïÂ∞ÜÂâçÁ´ØÁªÑ‰ª∂‰∏éÊñ∞ÁöÑÂêéÁ´ØÈ©±Âä®Â∑•‰ΩúÊµÅÁ≥ªÁªüÈõÜÊàêÔºåÂÆûÁé∞Êô∫ËÉΩÁöÑstep/stageÊµÅËΩ¨ÊéßÂà∂ÔºåÂêåÊó∂‰øùÊåÅÂâçÁ´ØÁä∂ÊÄÅÁÆ°ÁêÜÂíåagentÊÄùËÄÉËøáÁ®ãÁöÑÂÆåÊï¥ÊÄß„ÄÇ

This guide explains how to integrate frontend components with the new backend-driven workflow system for intelligent step/stage flow control while maintaining frontend state management and agent thinking processes.

## üèóÔ∏è Á≥ªÁªüÊû∂ÊûÑ System Architecture

### Ê†∏ÂøÉÂéüÂàô Core Principles

1. **ÂêéÁ´ØÈ©±Âä®ÂÜ≥Á≠ñ** - Backend makes all flow decisions
2. **Êó†Áä∂ÊÄÅÂêéÁ´Ø** - Backend remains stateless
3. **ÂâçÁ´ØÁä∂ÊÄÅÁÆ°ÁêÜ** - Frontend preserves all state and context
4. **AgentÊÄùËÄÉ‰øùÊåÅ** - Agent thinking processes maintained on frontend
5. **StepTemplateÂçèËÆÆÂÖºÂÆπ** - Full compatibility with existing frontend protocol

### Êû∂ÊûÑÁªÑ‰ª∂ Architecture Components

```
Frontend (React/Vue)
‚îú‚îÄ‚îÄ Workflow Manager        # Â∑•‰ΩúÊµÅÁÆ°ÁêÜÂô®
‚îú‚îÄ‚îÄ State Manager          # Áä∂ÊÄÅÁÆ°ÁêÜÂô®  
‚îú‚îÄ‚îÄ Agent Thinking UI      # AgentÊÄùËÄÉÁïåÈù¢
‚îú‚îÄ‚îÄ Step Template Handler  # StepTemplateÂ§ÑÁêÜÂô®
‚îî‚îÄ‚îÄ Backend API Client     # ÂêéÁ´ØAPIÂÆ¢Êà∑Á´Ø

Backend (Stateless)
‚îú‚îÄ‚îÄ Workflow Controller    # Â∑•‰ΩúÊµÅÊéßÂà∂Âô®
‚îú‚îÄ‚îÄ Flow Logic Engine     # ÊµÅÁ®ãÈÄªËæëÂºïÊìé
‚îú‚îÄ‚îÄ Agent Orchestrator    # AgentÁºñÊéíÂô®
‚îî‚îÄ‚îÄ State Adapter         # Áä∂ÊÄÅÈÄÇÈÖçÂô®
```

## üîÑ Â∑•‰ΩúÊµÅÁîüÂëΩÂë®Êúü Workflow Lifecycle

### 1. ‰ºöËØùÂàõÂª∫ Session Creation

**ÂâçÁ´ØË∞ÉÁî® Frontend Call:**
```javascript
// Create new workflow session
const response = await fetch('/api/workflow/create', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    user_context: {
      problem_description: "Áî®Êà∑ÈóÆÈ¢òÊèèËø∞",
      context_description: "Êï∞ÊçÆËÉåÊôØÊèèËø∞", 
      dataset_path: "/path/to/dataset.csv",
      user_preferences: {
        language: "zh-CN",
        detailed_explanations: true
      }
    },
    initial_inputs: {}
  })
});

const sessionData = await response.json();
```

**ÂìçÂ∫îÊ†ºÂºè Response Format:**
```javascript
{
  // StepTemplate compatible response
  "actions": [...],
  "variables": {...},
  "state": {...},
  
  // Workflow control information
  "workflow_control": {
    "workflow_id": "uuid",
    "backend_driven": true,
    "next_endpoint": "/api/workflow/execute_step",
    "session_data": {...}
  },
  
  // Frontend state management
  "frontend_state_management": {
    "state_summary": {...},
    "agent_thinking_preserved": true,
    "stateless_backend": true,
    "state_checkpoint": {...}
  }
}
```

### 2. Ê≠•È™§ÊâßË°å Step Execution

**ÂâçÁ´ØË∞ÉÁî® Frontend Call:**
```javascript
// Execute workflow step
const executeStep = async (stepInputs) => {
  const response = await fetch('/api/workflow/execute_step', {
    method: 'POST', 
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      workflow_id: currentWorkflowId,
      step_inputs: stepInputs,
      frontend_state: {
        user_preferences: userPreferences,
        ui_state: currentUIState,
        agent_thinking_history: agentThinkingHistory
      }
    })
  });
  
  return await response.json();
};
```

**ÂìçÂ∫îÂ§ÑÁêÜ Response Handling:**
```javascript
const handleStepResponse = (response) => {
  // 1. Process StepTemplate actions (existing logic)
  processStepTemplateActions(response.actions);
  
  // 2. Handle backend flow decisions
  const flowDecision = response.workflow_control.flow_decision;
  const nextAction = response.workflow_control.next_action;
  
  switch (flowDecision) {
    case 'proceed_to_next_step':
      updateWorkflowPosition(nextAction.next_stage, nextAction.next_step);
      break;
    case 'proceed_to_next_stage': 
      showStageTransition(nextAction.next_stage);
      updateWorkflowPosition(nextAction.next_stage, nextAction.next_step);
      break;
    case 'require_user_input':
      showInputRequestDialog(nextAction.required_inputs);
      break;
    case 'complete_workflow':
      showWorkflowCompletion();
      break;
  }
  
  // 3. Update frontend state
  updateFrontendState(response.frontend_state_management);
};
```

## üß† AgentÊÄùËÄÉÁä∂ÊÄÅÁÆ°ÁêÜ Agent Thinking State Management

### ÊÄùËÄÉÁä∂ÊÄÅÁªÑ‰ª∂ Thinking State Component

```javascript
// React Component Example
const AgentThinkingDisplay = ({ workflowId, agentName }) => {
  const [thinkingState, setThinkingState] = useState(null);
  
  // Subscribe to thinking updates
  useEffect(() => {
    const subscription = subscribeToThinkingUpdates(workflowId, agentName, 
      (newThinkingState) => {
        setThinkingState(newThinkingState);
      }
    );
    
    return () => subscription.unsubscribe();
  }, [workflowId, agentName]);
  
  if (!thinkingState) return null;
  
  return (
    <div className="agent-thinking">
      <div className="thinking-header">
        <span className="agent-name">{thinkingState.agent_name}</span>
        <span className="confidence">{thinkingState.confidence_level}%</span>
      </div>
      
      {!thinkingState.is_complete ? (
        <div className="thinking-in-progress">
          <div className="thinking-text">{thinkingState.thinking_text}</div>
          <div className="thinking-steps">
            {thinkingState.thinking_steps.map((step, index) => (
              <div key={index} className="thinking-step">
                {step}
              </div>
            ))}
          </div>
        </div>
      ) : (
        <div className="thinking-complete">
          <div className="final-thought">{thinkingState.thinking_text}</div>
        </div>
      )}
    </div>
  );
};
```

### ÊÄùËÄÉÁä∂ÊÄÅÂêåÊ≠• Thinking State Sync

```javascript
// Frontend State Manager
class FrontendStateManager {
  constructor(workflowId) {
    this.workflowId = workflowId;
    this.state = {
      agentThinking: new Map(),
      stepStates: new Map(),
      workflowPosition: { stage: null, step: null },
      userPreferences: {},
      executionHistory: []
    };
  }
  
  updateAgentThinking(agentName, thinkingUpdate) {
    // Update local thinking state
    this.state.agentThinking.set(agentName, {
      ...this.state.agentThinking.get(agentName),
      ...thinkingUpdate,
      lastUpdate: new Date().toISOString()
    });
    
    // Notify components
    this.notifySubscribers('thinking_updated', { agentName, thinkingUpdate });
    
    // Sync with backend periodically
    this.scheduleStateSync();
  }
  
  syncWithBackend() {
    return fetch('/api/workflow/sync_state', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        workflow_id: this.workflowId,
        frontend_state: {
          user_preferences: this.state.userPreferences,
          ui_state: this.getUIState()
        }
      })
    });
  }
  
  createCheckpoint() {
    return fetch('/api/workflow/create_checkpoint', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        workflow_id: this.workflowId
      })
    });
  }
}
```

## üìä Â∑•‰ΩúÊµÅËøõÂ∫¶ÊòæÁ§∫ Workflow Progress Display

### ËøõÂ∫¶ÁªÑ‰ª∂ Progress Component

```javascript
const WorkflowProgress = ({ workflowId }) => {
  const [progress, setProgress] = useState(null);
  
  useEffect(() => {
    const fetchProgress = async () => {
      const response = await fetch(`/api/workflow/status?workflow_id=${workflowId}`);
      const statusData = await response.json();
      setProgress(statusData.progress);
    };
    
    fetchProgress();
    const interval = setInterval(fetchProgress, 5000); // Update every 5 seconds
    
    return () => clearInterval(interval);
  }, [workflowId]);
  
  if (!progress) return <div>Loading...</div>;
  
  return (
    <div className="workflow-progress">
      <div className="overall-progress">
        <div className="progress-bar">
          <div 
            className="progress-fill" 
            style={{ width: `${progress.overall_progress * 100}%` }}
          />
        </div>
        <span>{Math.round(progress.overall_progress * 100)}% Complete</span>
      </div>
      
      <div className="stage-progress">
        {Object.entries(progress.stage_progress).map(([stageId, stageData]) => (
          <div key={stageId} className={`stage ${stageData.status}`}>
            <div className="stage-name">Stage {stageId}</div>
            <div className="stage-completion">
              {stageData.completed_steps.length}/{stageData.total_steps} steps
            </div>
          </div>
        ))}
      </div>
      
      <div className="current-position">
        <span>Current: Stage {progress.current_stage} - Step {progress.current_step}</span>
      </div>
    </div>
  );
};
```

## üîÑ ÂêéÁ´ØÂÜ≥Á≠ñÂ§ÑÁêÜ Backend Decision Handling

### ÂÜ≥Á≠ñÂ§ÑÁêÜÂô® Decision Handler

```javascript
class WorkflowDecisionHandler {
  constructor(workflowId, stateManager) {
    this.workflowId = workflowId;
    this.stateManager = stateManager;
  }
  
  async handleFlowDecision(decision, nextAction, confidence) {
    console.log(`Backend decision: ${decision} (confidence: ${confidence})`);
    
    switch (decision) {
      case 'proceed_to_next_step':
        await this.proceedToNextStep(nextAction);
        break;
        
      case 'proceed_to_next_stage':
        await this.proceedToNextStage(nextAction);
        break;
        
      case 'require_user_input':
        await this.requestUserInput(nextAction.required_inputs);
        break;
        
      case 'repeat_current_step':
        await this.repeatCurrentStep(nextAction);
        break;
        
      case 'complete_workflow':
        await this.completeWorkflow();
        break;
        
      case 'handle_error':
        await this.handleError(nextAction);
        break;
        
      default:
        console.warn(`Unknown flow decision: ${decision}`);
    }
  }
  
  async proceedToNextStep(nextAction) {
    // Update UI to show transition
    this.showStepTransition(nextAction.next_step);
    
    // Update workflow position
    this.stateManager.updateWorkflowPosition(
      nextAction.next_stage, 
      nextAction.next_step
    );
    
    // Auto-execute if no user input required
    if (nextAction.required_inputs.length === 0) {
      setTimeout(() => {
        this.executeNextStep({});
      }, 1000);
    } else {
      this.requestUserInput(nextAction.required_inputs);
    }
  }
  
  async proceedToNextStage(nextAction) {
    // Show stage completion celebration
    this.showStageCompletion();
    
    // Show stage transition animation
    await this.showStageTransition(nextAction.next_stage);
    
    // Update position and proceed
    this.stateManager.updateWorkflowPosition(
      nextAction.next_stage, 
      nextAction.next_step
    );
    
    // Start first step of new stage
    if (nextAction.required_inputs.length === 0) {
      setTimeout(() => {
        this.executeNextStep({});
      }, 2000);
    }
  }
  
  async requestUserInput(requiredInputs) {
    // Show input form modal
    const inputForm = new InputFormModal(requiredInputs);
    const userInputs = await inputForm.show();
    
    // Execute with user inputs
    if (userInputs) {
      this.executeNextStep(userInputs);
    }
  }
}
```

## üé® UI/UX ÈõÜÊàêÁ§∫‰æã UI/UX Integration Examples

### ‰∏ªÂ∑•‰ΩúÊµÅÁªÑ‰ª∂ Main Workflow Component

```javascript
const DCLSWorkflow = () => {
  const [workflowState, setWorkflowState] = useState({
    workflowId: null,
    currentStage: null,
    currentStep: null,
    isLoading: false,
    error: null
  });
  
  const [stateManager, setStateManager] = useState(null);
  const [decisionHandler, setDecisionHandler] = useState(null);
  
  // Initialize workflow
  const initializeWorkflow = async (userContext) => {
    setWorkflowState(prev => ({ ...prev, isLoading: true }));
    
    try {
      const response = await fetch('/api/workflow/create', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ user_context: userContext })
      });
      
      const sessionData = await response.json();
      
      // Create state manager
      const manager = new FrontendStateManager(sessionData.workflow_control.workflow_id);
      setStateManager(manager);
      
      // Create decision handler
      const handler = new WorkflowDecisionHandler(sessionData.workflow_control.workflow_id, manager);
      setDecisionHandler(handler);
      
      // Update workflow state
      setWorkflowState({
        workflowId: sessionData.workflow_control.workflow_id,
        currentStage: sessionData.workflow_control.session_data.current_stage,
        currentStep: sessionData.workflow_control.session_data.current_step,
        isLoading: false,
        error: null
      });
      
      // Process initial StepTemplate actions
      processStepTemplateActions(sessionData.actions);
      
    } catch (error) {
      setWorkflowState(prev => ({ 
        ...prev, 
        isLoading: false, 
        error: error.message 
      }));
    }
  };
  
  // Execute workflow step
  const executeStep = async (stepInputs) => {
    if (!workflowState.workflowId) return;
    
    setWorkflowState(prev => ({ ...prev, isLoading: true }));
    
    try {
      const response = await fetch('/api/workflow/execute_step', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          workflow_id: workflowState.workflowId,
          step_inputs: stepInputs,
          frontend_state: stateManager.getStateForBackend()
        })
      });
      
      const result = await response.json();
      
      // Process StepTemplate actions
      processStepTemplateActions(result.actions);
      
      // Handle backend decision
      await decisionHandler.handleFlowDecision(
        result.workflow_control.flow_decision,
        result.workflow_control.next_action,
        result.confidence
      );
      
      // Update frontend state
      stateManager.updateFromBackendResponse(result.frontend_state_management);
      
      setWorkflowState(prev => ({ ...prev, isLoading: false }));
      
    } catch (error) {
      setWorkflowState(prev => ({ 
        ...prev, 
        isLoading: false, 
        error: error.message 
      }));
    }
  };
  
  return (
    <div className="dcls-workflow">
      {!workflowState.workflowId ? (
        <WorkflowInitializer onInitialize={initializeWorkflow} />
      ) : (
        <>
          <WorkflowProgress workflowId={workflowState.workflowId} />
          <AgentThinkingDisplay 
            workflowId={workflowState.workflowId} 
            agentName="current" 
          />
          <StepTemplateRenderer 
            workflowId={workflowState.workflowId}
            onExecuteStep={executeStep}
          />
          <WorkflowControls 
            workflowId={workflowState.workflowId}
            stateManager={stateManager}
          />
        </>
      )}
    </div>
  );
};
```

## üîß ÈÖçÁΩÆÂíåËÆæÁΩÆ Configuration and Settings

### ÁéØÂ¢ÉÈÖçÁΩÆ Environment Configuration

```javascript
// config/workflow.js
export const WORKFLOW_CONFIG = {
  // API endpoints
  endpoints: {
    create: '/api/workflow/create',
    execute: '/api/workflow/execute_step',
    status: '/api/workflow/status',
    sync: '/api/workflow/sync_state',
    checkpoint: '/api/workflow/create_checkpoint'
  },
  
  // UI settings
  ui: {
    autoProgressDelay: 1000,
    thinkingUpdateInterval: 500,
    statusCheckInterval: 5000,
    showConfidenceLevel: true,
    enableAutoTransitions: true
  },
  
  // State management
  state: {
    syncInterval: 10000, // 10 seconds
    checkpointInterval: 60000, // 1 minute
    maxHistoryLength: 100,
    persistToLocalStorage: true
  }
};
```

## üì± ÂìçÂ∫îÂºèËÆæËÆ°ËÄÉËôë Responsive Design Considerations

### ÁßªÂä®Á´ØÈÄÇÈÖç Mobile Adaptation

```css
/* Responsive workflow styles */
.dcls-workflow {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

@media (max-width: 768px) {
  .workflow-progress {
    flex-direction: column;
    padding: 10px;
  }
  
  .agent-thinking {
    font-size: 14px;
    padding: 8px;
  }
  
  .stage-progress {
    display: grid;
    grid-template-columns: 1fr;
    gap: 8px;
  }
}

@media (min-width: 1024px) {
  .dcls-workflow {
    flex-direction: row;
  }
  
  .workflow-sidebar {
    width: 300px;
    flex-shrink: 0;
  }
  
  .workflow-main {
    flex: 1;
    padding-left: 20px;
  }
}
```

## üß™ ÊµãËØïÁ≠ñÁï• Testing Strategy

### ÂçïÂÖÉÊµãËØï Unit Tests

```javascript
// tests/workflow.test.js
describe('Workflow Integration', () => {
  test('should create workflow session', async () => {
    const userContext = {
      problem_description: "Test problem",
      context_description: "Test context"
    };
    
    const response = await createWorkflowSession(userContext);
    
    expect(response.workflow_control.workflow_id).toBeDefined();
    expect(response.workflow_control.backend_driven).toBe(true);
    expect(response.frontend_state_management.stateless_backend).toBe(true);
  });
  
  test('should handle flow decisions correctly', async () => {
    const handler = new WorkflowDecisionHandler('test-id', mockStateManager);
    
    await handler.handleFlowDecision('proceed_to_next_step', {
      next_step: 'step_2',
      next_stage: 'stage_0',
      required_inputs: []
    }, 0.8);
    
    expect(mockStateManager.updateWorkflowPosition).toHaveBeenCalledWith('stage_0', 'step_2');
  });
});
```

## üöÄ ÈÉ®ÁΩ≤ÂíåÁõëÊéß Deployment and Monitoring

### ÊÄßËÉΩÁõëÊéß Performance Monitoring

```javascript
// monitoring/workflow-metrics.js
class WorkflowMetrics {
  constructor() {
    this.metrics = {
      stepExecutionTimes: [],
      thinkingUpdateFrequency: 0,
      stateSyncOperations: 0,
      backendDecisionAccuracy: []
    };
  }
  
  recordStepExecution(startTime, endTime, success) {
    const duration = endTime - startTime;
    this.metrics.stepExecutionTimes.push({
      duration,
      success,
      timestamp: new Date()
    });
    
    // Send to analytics
    this.sendMetric('step_execution', { duration, success });
  }
  
  recordBackendDecision(decision, confidence, userSatisfaction) {
    this.metrics.backendDecisionAccuracy.push({
      decision,
      confidence,
      userSatisfaction,
      timestamp: new Date()
    });
  }
}
```

## üìö ÊúÄ‰Ω≥ÂÆûË∑µ Best Practices

### 1. Áä∂ÊÄÅÁÆ°ÁêÜÊúÄ‰Ω≥ÂÆûË∑µ State Management Best Practices

- **‰øùÊåÅÁä∂ÊÄÅÂêåÊ≠•È¢ëÁéáÂêàÁêÜ** - ÈÅøÂÖçËøá‰∫éÈ¢ëÁπÅÁöÑÁä∂ÊÄÅÂêåÊ≠•
- **‰ΩøÁî®Èò≤ÊäñÂ§ÑÁêÜÁî®Êà∑ËæìÂÖ•** - ÈÅøÂÖçÁä∂ÊÄÅÊõ¥Êñ∞È£éÊö¥
- **ÂÆûÁé∞‰ºòÈõÖÁöÑÈîôËØØÊÅ¢Â§ç** - Êèê‰æõÊ∏ÖÊô∞ÁöÑÈîôËØØÁä∂ÊÄÅÂíåÊÅ¢Â§çÈÄâÈ°π
- **ÁºìÂ≠òÂÖ≥ÈîÆÁä∂ÊÄÅ** - Âú®Êú¨Âú∞Â≠òÂÇ®‰∏≠ÁºìÂ≠òÈáçË¶ÅÁöÑÂ∑•‰ΩúÊµÅÁä∂ÊÄÅ

### 2. Áî®Êà∑‰ΩìÈ™åÊúÄ‰Ω≥ÂÆûË∑µ UX Best Practices

- **Êèê‰æõÊ∏ÖÊô∞ÁöÑËøõÂ∫¶ÊåáÁ§∫** - Áî®Êà∑ÂßãÁªàÁü•ÈÅìÂΩìÂâç‰ΩçÁΩÆÂíåÂâ©‰ΩôÂ∑•‰Ωú
- **ÊòæÁ§∫agentÊÄùËÄÉËøáÁ®ã** - Â¢ûÂº∫Áî®Êà∑ÂØπAIÂÜ≥Á≠ñÁöÑ‰ø°‰ªª
- **ÊîØÊåÅÂ∑•‰ΩúÊµÅÊöÇÂÅú/ÊÅ¢Â§ç** - ÂÖÅËÆ∏Áî®Êà∑ÁÅµÊ¥ªÊéßÂà∂ÊâßË°åËäÇÂ•è
- **Êèê‰æõÂÜ≥Á≠ñÈÄèÊòéÂ∫¶** - Ëß£ÈáäÂêéÁ´ØÂÅöÂá∫ÁöÑÊµÅÁ®ãÂÜ≥Á≠ñ

### 3. ÊÄßËÉΩ‰ºòÂåñÊúÄ‰Ω≥ÂÆûË∑µ Performance Best Practices

- **ÊáíÂä†ËΩΩÈùûÂÖ≥ÈîÆÁªÑ‰ª∂** - ÂáèÂ∞ëÂàùÂßãÂä†ËΩΩÊó∂Èó¥
- **‰ΩøÁî®ËôöÊãüÊªöÂä®** - Â§ÑÁêÜÂ§ßÈáèÂéÜÂè≤Êï∞ÊçÆÊó∂‰øùÊåÅÊÄßËÉΩ
- **ÂÆûÁé∞Êô∫ËÉΩÁºìÂ≠òÁ≠ñÁï•** - ÁºìÂ≠òfrequently accessedÊï∞ÊçÆ
- **‰ºòÂåñÁΩëÁªúËØ∑Ê±Ç** - ÊâπÈáèÂ§ÑÁêÜÂíåÂéªÈáçÂ§çËØ∑Ê±Ç

## üîÆ Êú™Êù•Êâ©Â±ï Future Extensions

### 1. È´òÁ∫ßÂäüËÉΩÊâ©Â±ï

- **Â∑•‰ΩúÊµÅÊ®°ÊùøÁ≥ªÁªü** - È¢ÑÂÆö‰πâÁöÑÂ∑•‰ΩúÊµÅÊ®°Êùø
- **Â§öÂ∑•‰ΩúÊµÅÂπ∂Ë°åÊâßË°å** - ÂêåÊó∂ÁÆ°ÁêÜÂ§ö‰∏™Â∑•‰ΩúÊµÅ‰ºöËØù
- **Âçè‰ΩúÂäüËÉΩ** - Â§öÁî®Êà∑Âçè‰ΩúÁºñËæëÂíåÊâßË°åÂ∑•‰ΩúÊµÅ
- **Â∑•‰ΩúÊµÅÁâàÊú¨ÊéßÂà∂** - Ë∑üË∏™Â∑•‰ΩúÊµÅÁöÑÂèòÊõ¥ÂéÜÂè≤

### 2. ÈõÜÊàêÊâ©Â±ï

- **Á¨¨‰∏âÊñπÊúçÂä°ÈõÜÊàê** - ËøûÊé•Â§ñÈÉ®Êï∞ÊçÆÊ∫êÂíåÊúçÂä°
- **APIÁΩëÂÖ≥ÈõÜÊàê** - Áªü‰∏ÄÁöÑAPIÁÆ°ÁêÜÂíåÁõëÊéß
- **ÂæÆÊúçÂä°Êû∂ÊûÑÊîØÊåÅ** - ÂàÜÂ∏ÉÂºèÂ∑•‰ΩúÊµÅÊâßË°å
- **‰∫ëÂéüÁîüÈÉ®ÁΩ≤** - KubernetesÂíåÂÆπÂô®ÂåñÊîØÊåÅ

---

## üìû ÊîØÊåÅÂíåÂèçÈ¶à Support and Feedback

Â¶ÇÊúâ‰ªª‰ΩïÈóÆÈ¢òÊàñÂª∫ËÆÆÔºåËØ∑ËÅîÁ≥ªÂºÄÂèëÂõ¢ÈòüÊàñÊèê‰∫§GitHub Issue„ÄÇ

For any questions or suggestions, please contact the development team or submit a GitHub issue.

**ÊñáÊ°£ÁâàÊú¨**: v1.0  
**ÊúÄÂêéÊõ¥Êñ∞**: 2024Âπ¥  
**ÈÄÇÁî®ÁâàÊú¨**: DCLS Workflow System v2.0+